> 本文源自《大型多人在线游戏开发》第1.4节 使用支付矩阵来设计游戏平衡和 AI

John M. Olsen, Microsoft Corporation  
infix@xmission.com

游戏平衡是一个非常棘手的问题，游戏设计人员必须投入大量时间才能获得正确的结果。在 MMP 游戏环境中，任何错误都会引起重大问题。玩家会通过合作来发现任何微小的优势并且加以利用，他们在这方面的能力超乎寻常。在这样的环境下，几乎每个游戏都有它独特的游戏平衡方法。本文介绍了怎样使用统计分析和一些简单的数学方法来简化游戏中特定部分的平衡工作，这些技术也可以用来确保 AI 程序利用了所有有利条件。

# 1 什么是支付矩阵？
支付矩阵（Payoff Matrix）是一个博弈论概念。博弈论主要是在约翰·冯诺依曼和奥斯卡·摩根斯查的研究基础上发展而来的。这种矩阵用来表示博弈中两个或更多的参与者在做出不同决定时所获得的收益或惩罚。在博弈论中，一次“博弈”是指这样一个竞赛：在一次或多次对抗后，一个参与者获胜而另一个失败。可以根据参与者所做的选择从这个矩阵中得到他们的分数。

首先，看一下在图 1-5 中玩家 1 身上发生了什么。可以通过在左边的列中查找他的选择并且在表格上方查找对手的选择来得到他的分数。

再来看看玩家2的情况。图 1-6 是另一个版本，它包含了玩家2的分数。

现在对它们做一些简化，把这些矩阵组合在一起，使用一些颜色编码来同时显示两个参与者的分数。

要使用图 1-7 中的矩阵，需要获得两个玩家的选择并且在矩阵中查找相应的单元。第一个数字是玩家1的分数，第二个数字是玩家2的分数。玩家标志中的阴影和他们在每个单元中所获得的分数的阴影一致，这使得表格的可读性更强。

 &nbsp;| 玩家2选择1 | 玩家2选择2
---|---|---
玩家1选择1 | 玩家1获得0分 | 玩家1获得-1分
玩家1选择2 | 玩家1获得1分 | 玩家1获得0分
*图 1-5：玩家1的回报矩阵*

 &nbsp;| 玩家2选择1 | 玩家2选择2
---|---|---
玩家1选择1 | 玩家2获得0分 | 玩家2获得1分
玩家1选择2 | 玩家2获得-1分 | 玩家2获得0分
*图 1-6：玩家2的回报矩阵*

 &nbsp;| 玩家2选择1 | 玩家2选择1 | 玩家2选择2 | 玩家2选择2
---|---|---|---|---
**玩家1选择1** | **0** | 0 | **-1** | 1
**玩家1选择2** | **1** | -1 | **0** | 0
*图 1-7：玩家1和玩家2回报矩阵的组合*

图 1-7 所示的矩阵还有一个额外的特征。如果把每个单元格中的两个分数加在一起，和都为0。这是一个零和博弈，它确保在每个回合中，如果有一个胜利者，就必然有一个失败者。同时也确保在经过一系列的竞赛之后，玩家1的是玩家2分数的相反数。

# 2 “War” 纸牌游戏
War 是一种非常简单的古老游戏，它使用一副纸牌来进行。每个参与者取出他们手中纸牌最上面的一张。牌大的玩家可以得到这两张纸牌，如果是平局，那么它们由下一轮的胜利者获得。表3可以用来表示该游戏的一个简化版本。每个参与者可以出一张小牌或是一张大牌。如果玩家1出大牌（选择2），玩家2出小牌（选择1），那么玩家1获得一分，玩家2失去一分。如果他们都出小牌或者都出大牌，那就形成平局，没有人得分。

这是一个经过大量简化的例子，只是为了让读者知道这种矩阵是怎样应用于一个熟悉的游戏中的。下面本节会讨论一些更复杂的问题和用法。

# 3 囚徒困境（Prisoner's Dilemma）
囚徒困境是两个罪犯被警察逮捕后所进行的博弈。如果他们都不招供，他们面对的指控是无力的，因此他们每人会被判入狱一年。如果其中一人招供并且作出不利于另一人的证供，他所得到的奖励是只需入狱服刑3个月，而另一个罪犯将会入狱10年。如果两人都招供，那么他们每人都需要入狱8年。每个人都必须在不知道对方决定的情况下，决定是招供还是保持沉默。

这个困境的矩阵可以帮助游戏设计人员理解所发生的事情，如图 1-8 所示。

 &nbsp;| 参与者2保持沉默 | 参与者2保持沉默 | 参与者2招供 | 参与者2招供
---|---|---|---|---
**参与者1保持沉默** | **-1** | -1 | **-10** | -0.25
**参与者1招供** | **-0.25** | -10 | **-8** | -8
*图 1-8：囚徒困境的支付矩阵*

很容易看到，对于参与者1来说，最好的情况是他招供而参与者2保持沉默。问题在于参与者1并不知道参与者2会怎样决定。参与者1必须根据参与者2可能作出的对他最不利的决定来作出他的决定（译者注：这里参与者1这样做选择的原因其实是因为他和参与者2都知道他们在各种选择组合下的结果，因此他知道无论参与者2做出什么选择，他选择招供总比选择保持沉默获得的好处要大，所以选择招供对他来说是明智的，请参考相关博弈论书籍以获得更详细的解释）。如果参与者1保持沉默，可能发生的最坏情况是入狱10年。如果他招供了，最坏的可能是入狱8年。

两个参与者都招供的状态具有一个有趣的特性，那就是在另一个参与者没有改变策略的前提下，任何一个参与者都不会选择离开这个状态。这被称为[纳什均衡](https://wiki.mbalib.com/wiki/%E7%BA%B3%E4%BB%80%E5%9D%87%E8%A1%A1)。如果一个参与者在其他参与者没有改变主意的情况下离开这个状态，也就是说他选择保持沉默，那么他会获得两年额外的徒刑，因此没有一个参与者会选择独自离开这个状态。

支付矩阵是表示这些状态和行为之间关系的一种紧凑形式，这里每个参与者在作出自己决定时都需要考虑其他参与者的行为。

# 4 简单的格斗游戏
现在本节开始讨论更加“动作化”的问题。图 1-9 是为一个简单的格斗游戏设计的支付矩阵，其中每个玩家可以选择攻击、格挡或是休息。这个矩阵并没有表示出游戏模式中的某些机制，譬如说每个状态的持续时间，本节将在后面做更详细的讨论。

这个矩阵被刻意地设计为每个状态都会对分数进行一些改变，这样可以使游戏变得更富于变化。矩阵显示了一次成功攻击的结果、格挡所付出的代价以及休息带来的好处。

这个矩阵中还可以提示一些有趣的游戏方式。如果一个玩家能够和对手保持一段距离，他就可以从休息中获益。但是一旦他的对手再次接近，这种好处将不复存在，因为在遭受攻击时，处于休息状态会带来更大的伤害。总是保持格挡状态的玩家将会受到处罚，因为格挡者会不停地失去点数而对手可以在不失去任何点数的情况下持续攻击。所有这些特性都倾向于让游戏可以结束而不是陷入僵局。

 &nbsp;| 玩家2进攻 | 玩家2进攻 |  玩家2格挡 | 玩家2格挡 | 玩家2休息 | 玩家2休息
---|---|---|---|---|---|---
**玩家1进攻** | **-10** | -10 | **0** | -1 | **0** | -20
**玩家1格挡** | **-1** | 0 | **-1** | -1 | **-1** | 1
**玩家1休息** | **-20** | 0 | **1** | -1 | **1** | 1
*图 1-9：一个简单格斗游戏的支付矩阵*

对这个矩阵进行进一步的分析后，通过在每行每列寻找最高分数，设计人员可以发现一个纳什均衡，并且消除那行或那列所有其他的结果。从被消除的单元画一个到这行或这列最优值的转换箭头就可以说明这个现象。如果对手在攻击，最好的选择是保持格挡。纳什均衡存在于任何没有外向的转换箭头的单元中，最后只剩下两个玩家都休息这个均衡状态。这些转换如图 1-10 所示。

![图1-10 表示怎样达到纳什均衡状态的有向支付矩阵](https://github.com/najoast/GameDesign/blob/master/images/211005-1.png)

这个结果比囚徒困境中自相矛盾的方案要好得多。“要想大家都活命，就应该一起休息”，这一结论很有意义。

一个任意对称矩阵（按照对角线对称的矩阵）如果含有一个不在主对角线上的均衡状态，这个状态及其包含的数据都会被映射到主对角线的另一边。这意味着如果有一个不在主对象线上的均衡状态，那么在主对角线的另一边必然有一个一致的对称状态。

现在可以知道最佳选择是什么：如果两个玩家都想活命，那么就一起坐下休息。这个结果告诉设计人员必须对这个状态进行特别观察以防止被滥用。幸运的是，游戏中的玩家并不是以活命为目的的，他们还需要杀死对手。那些没有包含在矩阵中的游戏特性（譬如移动、位置和其他的游戏目标）可以用来打破这个均衡状态，这样可以避免游戏的结果被轻易地预测到。

必须注意的是纳什均衡并不考虑一个序列中的多个转换。即使有两个或者多个均衡状态，也不能在同一个回合中因为某一个玩家的决定而在它们之间变化。这意味着矩阵中没有一行或者一列可以有多于一个的均衡状态，所以均衡状态数的最大可能值是行数和列数这两者中较小的那个。然而，如果两个玩家同时改变状态，还是有可能在均衡状态间移动的。

玩家可能会故意地承担从一个均衡状态移出所受到的惩罚，从而通过在一系列可预测的状态中移动，最终达到一个战略上更有利的状态。这类有条件的均衡也可以使进行游戏的方式变得更为复杂。

只要矩阵是对称的，也就是说所有的玩家具有相同的能力并且受到同样的惩罚，就不会产生有关于玩家能力平衡上的问题。因为所有的玩家具有相同的能力，一个玩家无法获得比另一个玩家更多的内在优势。当然，一些和整体可玩性有关的平衡问题，譬如说有些玩家会认为某个设置过于愚蠢，这或多或少地困扰着每一个游戏设计。

# 5 不对称的能力
一旦玩家的能力不同，游戏设计人员就需要对玩家进行平衡，这是最具挑战性的任务之一，因为这个问题涉及的范围可能很大。如果玩家的能力、等级和类型差异很大，并且还有一些具有不同能力和特征的 NPC（计算机控制的非玩家角色），所需测试的组合很快就会成为天文数字。

MMP 游戏，可以把测试范围划分为特定的领域。首先，保持玩家之间的平衡，这样某个特定的职业或类型就不会在游戏中处于支配地位。其次，在进行完玩家之间的平衡后，要对玩家和 NPC 之间进行平衡也就更容易了。

图 1-11 是一个玩家与玩家间的测试，图中两个玩家的能力不一致。玩家1进攻可以造成更大的伤害，同时也需要更多的体力来格挡。这里仍然模仿图 1-9 中所描述的格斗游戏进行建模。

因为他们的能力不同，很可能某个玩家会具有一些优势。在试图为有区别的玩家类另建立平衡时，游戏设计人员需要密切注意失衡的情况。

*图 1-11：为一个玩家与玩家间的测试建立的不对称支付矩阵*
 &nbsp;| 玩家2进攻 | 玩家2进攻 |  玩家2格挡 | 玩家2格挡 | 玩家2休息 | 玩家2休息
---|---|---|---|---|---|---
**玩家1进攻** | **-10** | -15 | **0** | -1 | **0** | -30
**玩家1格挡** | **-2** | 0 | **-2** | -1 | **-2** | 1
**玩家1休息** | **-20** | 0 | **1** | -1 | **1** | 1

# 6 延迟和停止
现在是时候加入更多的复杂度了。从一个单纯的回合制系统演变到一个实时游戏会带来一些新的加求。第一步是定义每个状态所需最少和最多的时间，然后为每个状态添加一个转换表，这个转换表会显示在这个状态完成后可以进入哪些状态。现在试图对这个不对称矩阵进行平衡，加入一些延迟可以来抵消玩家1过强的攻击能力。图 1-12 显示了和前面一样的数据，但是它在每个状态中加入了时间范围以及可以进行合法转换的状态列表。这个矩阵加入了一些限制：不能重复同一个状态，并且攻击后必须休息。

*图 1-12：加入时间延迟和允许的转换*
 &nbsp; | 玩家2进攻</br>(0.3秒后进入休息状态) | 玩家2进攻 |  玩家2格挡</br>(0.1到2秒后进入休息或进攻状态) | 玩家2格挡</br>(0.3到无穷大秒后进入进攻或格挡状态) | 玩家2休息 | 玩家2休息
---|---|---|---|---|---|---
**玩家1进攻</br>(0.5秒后进入休息状态)** | **-10** | -15 | **0** | -1 | **0** | -30
**玩家1格挡</br>(0.2到2秒后进入休息或进攻状态)** | **-2** | 0 | **-2** | -1 | **-2** | 1
**玩家1休息</br>(0.3到无穷大秒后进入进攻或格挡状态)** | **-20** | 0 | **1** | -1 | **1** | 1

这个矩阵说明了怎样用速度来抵消玩家1的力量优势。如果他能够造成更大的伤害，那就应该让他更慢一点。考虑每秒的最大伤害，现在玩家1可以以0.5秒来进攻，然后休息0.3秒或更长时间，接着再重复进攻。这使他最多可以以30/0,8，也就是37.5点每秒的速度进行攻击。玩家二可以以0.3秒来进行更迅速的攻击，然后休息0.3秒或更长，这使得他可以以20/0.6，也就是33.3点每秒的速度进行攻击，这意味着他们之间的差距只不过略大于10%。虽然攻击力较强的玩家仍然具有一定的优势，但是时间上的要求把它大大地削弱了。

对合法的转换进行限制也增加了游戏的策略成分。如果玩家1正在进攻而玩家2正在格挡，那么玩家2就可以知道如果玩家1没有及时地从接下去的休息状态转移到格挡或是攻击状态，玩家2就有机会击中他。

前面本文简要地提到过一个状态间无法转换的情况：由于玩家不能在有效范围以外进行攻击，这限制了可以转换的状态。必须注意的是任意具有最大时间限制的状态都需要有一个允许的转换。如果有一些状态仅仅持续1秒并且要求紧接着一个进攻，那么在需要进攻时他在攻击范围之外就会遇到问题。要解决这个问题，玩家可以在任何时候都允许转换到一个在所有情况下都有效的状态，或是为攻击状态创建副本，譬如说“挥动武器但是未击中”，这样就可以在不能进行任何攻击时使用这个状态。

# 7 自动化
有两种方法可以把这些关于矩阵和均衡的理论应用到实际游戏中去：自动化的矩阵测试、记录模拟战斗或游戏中的战斗日志。设计人员只需要一点创造力就可以把任何战斗系统映射到一个支付矩阵中。矩阵的左边是一个战斗参与者可用的选择，矩阵的上边是另一个战斗参与者可用的选择。因为战斗系统可能允许可变伤害或是未击中的情况，矩阵中的支付值不一定是一个固定值。本文所介绍的方法也适用于可变支付的情况。

支付矩阵可以看成两个相交和状态机。在前面介绍的支付矩阵中，玩家1的状态机沿着左边显示，玩家2的状态机沿着上方显示，这两个状态机的交集就是支付信息。改变动作（也就是从一行移动到另一行或是从一列移动到另一列）就会导致状态转换。一个玩家控制列状态的变化，另一个玩家控制行状态的变化。

现在，只要选定两个敌对者，然后识别他们可以选择的动作列表，就可以为他们建立一个矩阵。对当前合法的目标状态进行估价，然后从中选择一个合法的新状态，这样就可以构造出一个复杂的 AI 系统。这个系统最复杂的部分是估价函数，它必须考虑 AI 的当前状态以及每个合法行为的支付。

在一个幻想游戏中，支付可以定义为在使用当前盔甲和武器的情况下，攻击可以造成 X 点的伤害；休息可以治愈 Y 点的伤害；施展某个魔法可以使对手暂时麻痹从而在一定程度上降低它的攻击力。一旦从估价函数获得这3个选项的不同结果，就可以从中作出选择。

要在这些选项中作出选择，加权随机数可以用来创建一个简单的模糊逻辑系统。关于模糊逻辑系统更详细的信息可以参考[McCuskey00]和[Dybsand01]。如果估价结果显示不同选项所带来的好处是7、5和8（数字越大表示这个选项越好），就可以使用一个在1到20（7+5+8）之间的随机数在它们之间做出选择。这样做可以使得所做的选择一直在变化，并且选择有些行为的可能性会变小，这可以让游戏变得更有趣。任意好处为0的选项在使用这种方法都会被自动忽略。一旦生成了随机数，在1和7之间的值对应于第一个选择，在8到12之间的值（包含5个数的区间）对应于第二个选项，在13到20之间的值（包含8个数的区间）对应于最后一个选项。

很多另外的方法都可以在多个有效单元的支付值中进行选择，但是它们的效果并不都很好。通常，如果对手因为某个动作比其他选项略微有利一些就一直选择这个动作的话，玩家会觉得很无趣。

正如前面提到过的，设计人员应该对矩阵中每个从当前单元中合法转换的单元进行估价。这就回到了图 1-12 中所示的时间限制和转换要求。如果仔细地选择操作的顺序，就可以为 AI 节约一些 CPU 时间。

设计人员可以先对当前是否存在可行的转换进行检查。如果没有，就可以在这次估价中忽略整个 AI 系统。接着可以过滤掉那些在当前情况下不允许的行为。

估价函数本身高度依赖于游戏，但是设计人员通常希望可以基于下面的条件对当前情况进行估价：耗费或是获得的资源、当前状态（包括生命值）的增加或减少，以及这些动作对朋友和敌人的能力所带来的影响。

一旦建立了估价函数，它就可以自动化地进行平衡和测试过程。通常，游戏中存在大量由群体和个体组成的独特组合，这对于测试来说简直是噩梦。这使它成为实施自动化的理想对象。

如果我们只在相当少的 AI 类别间进行测试，即使使用一个自动化的轮流对抗使每个类别都和所有其他类别进行对抗也很简单。在重复几次这样的对抗后，记录将呈现出一定的趋势，它可以告诉我们这些不同的对手之间是否平衡。通过对比不同类别的胜利次数，游戏设计人员可以知道相对其他类别来说，与这个类别作战的难度是多少。图 1-13 中每个单元都保存了矩阵左边的玩家相对于矩阵上方的玩家的胜利数。玩家不会和自己进行比赛。在20轮对抗后，通过比较胜利总数，可以知道玩家1最好而玩家3最差。如果希望这些玩家处于大致相同的等级，那么矩阵中的数字说明了还需要作一些调整，以提高玩家3的能力并且略微降低玩家1的能力。

千万不要以为这样的轮流测试就足够了，因为此时游戏完全依赖于尚未完善的 AI 代码。玩家可能会发现一些漏洞，这会使得游戏必须更新所有的日志数据。

 &nbsp; | 玩家1 | 玩家2 |  玩家3 | 总胜利数
---|---|---|---|---
玩家1 | 0 | 8 | 15 | 23
玩家2 | 12 | 0 | 9 | 21
玩家3 | 5 | 11 | 0 | 16
*图1-13：20次对抗后的胜利结果示例*

设计人员一旦可以对 AI 控制的对手之间的回合制战斗进行记录，就应该开始记录 AI 对手和玩家控制的对手之间的战斗结果。坦白地说，这部分工作应该在第一次使用战斗代码时就开始，并且直到游戏最终被关闭前一直进行。随着玩家的不断成熟以及游戏的不断更新，在玩家和 AI 间进行调整必须是一个持续的过程。这不仅非常复杂，还很棘手。每当设计人员根据玩家和 AI 之间的交互性测试对支付矩阵做出任何修改后，他们必须对这些修改重新进行前面所描写的 AI 对 AI 的自动化测试，这样 AI 就可以通过学习来弥补玩家所发现的漏洞，从而变得更为精确。

一对一的记录是最容易进行的，但是 MMP 游戏的主要目的之一就是倡导团队合作。通过计算团队间（无论这些团队是否是 AI 控制的）的数据，我们可以获得全新的数据。数据的复杂度会很快增长，并且具有大量的可能组合。对可能组合进行过滤，从而获得有用组合的方法完全依赖于具体的游戏设计。这通常会从游戏中可以预测的，或是已观察到的情况开始，当注意到记录文件中有奇怪的事情发生时，再把他们也加入。

当数据中某个特定的 AI 类别或是玩家类别/群主在战斗中胜利或失败的次数过多时，很多方法都可以对它加以解决。查找历史记录的趋势，或者是进行一些自动化测试，可以决定矩阵中的哪个支付值需要被调整，简单地通过观察用户的行动也可以做出这个决定。当发现某些地方效果不是很好时，只需要改变攻击方式的使用频率或是调整行为之间的延迟就可以获得完全不同的结果。

# 8 总结
令人惊讶的是，纳什均衡以及相关的博弈论知识通常应用在与商业和经济相关的模拟中，而不是用在互动娱乐产业中。Paul Walker 整理了一份博弈论的简要历史。通过对本文讨论的问题的理论基础加以利用，设计人员可以对系统的行为进行更严格的定义，而采用统一的方法进行设计也会更加方便。在使用非正式方法的系统中，随着测试在最初的设计中发行更多的漏洞，必须对它进行不断地扩展和改变，与之相比，使用上述方法进行的设计更容易被实现。

从某种观点来看，所有这一切只不过是在做那些总要做的事情。检查自己有哪些选项，接着在那些有意义的选项中做出选择，然后通过对玩家或 AI 有利的情况进行查找，来发现那些相持状态（static state）或是可能存在麻烦的地方。

本文所描述的方法最主要的优点，在于它使用易于理解的格式来对非常复杂并且不可靠的设计进行组织。这有助于使用一致的方法对 AI 和战斗系统进行创建、分析和调整，并且在获得稳定性的同时避免过多的限制和开销。


